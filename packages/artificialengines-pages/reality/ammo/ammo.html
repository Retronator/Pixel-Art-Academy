<template name="Artificial.Reality.Pages.Ammo">
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
  </style>

  <div class="artificial-reality-pages-ammo">
    <div id="container">Loading...</div>

    <script>
      /**
       * @author qiao / https://github.com/qiao
       * @author mrdoob / http://mrdoob.com
       * @author alteredq / http://alteredqualia.com/
       * @author WestLangley / http://github.com/WestLangley
       * @author erich666 / http://erichaines.com
       */

      // This set of controls performs orbiting, dollying (zooming), and panning.
      // Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
      //
      //    Orbit - left mouse / touch: one-finger move
      //    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
      //    Pan - right mouse, or arrow keys / touch: two-finger move

      THREE.OrbitControls = function ( object, domElement ) {

        this.object = object;

        this.domElement = ( domElement !== undefined ) ? domElement : document;

        // Set to false to disable this control
        this.enabled = true;

        // "target" sets the location of focus, where the object orbits around
        this.target = new THREE.Vector3();

        // How far you can dolly in and out ( PerspectiveCamera only )
        this.minDistance = 0;
        this.maxDistance = Infinity;

        // How far you can zoom in and out ( OrthographicCamera only )
        this.minZoom = 0;
        this.maxZoom = Infinity;

        // How far you can orbit vertically, upper and lower limits.
        // Range is 0 to Math.PI radians.
        this.minPolarAngle = 0; // radians
        this.maxPolarAngle = Math.PI; // radians

        // How far you can orbit horizontally, upper and lower limits.
        // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
        this.minAzimuthAngle = - Infinity; // radians
        this.maxAzimuthAngle = Infinity; // radians

        // Set to true to enable damping (inertia)
        // If damping is enabled, you must call controls.update() in your animation loop
        this.enableDamping = false;
        this.dampingFactor = 0.25;

        // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
        // Set to false to disable zooming
        this.enableZoom = true;
        this.zoomSpeed = 1.0;

        // Set to false to disable rotating
        this.enableRotate = true;
        this.rotateSpeed = 1.0;

        // Set to false to disable panning
        this.enablePan = true;
        this.panSpeed = 1.0;
        this.screenSpacePanning = false; // if true, pan in screen-space
        this.keyPanSpeed = 7.0;	// pixels moved per arrow key push

        // Set to true to automatically rotate around the target
        // If auto-rotate is enabled, you must call controls.update() in your animation loop
        this.autoRotate = false;
        this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

        // Set to false to disable use of the keys
        this.enableKeys = true;

        // The four arrow keys
        this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

        // Mouse buttons
        this.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };

        // for reset
        this.target0 = this.target.clone();
        this.position0 = this.object.position.clone();
        this.zoom0 = this.object.zoom;

        //
        // public methods
        //

        this.getPolarAngle = function () {

          return spherical.phi;

        };

        this.getAzimuthalAngle = function () {

          return spherical.theta;

        };

        this.saveState = function () {

          scope.target0.copy( scope.target );
          scope.position0.copy( scope.object.position );
          scope.zoom0 = scope.object.zoom;

        };

        this.reset = function () {

          scope.target.copy( scope.target0 );
          scope.object.position.copy( scope.position0 );
          scope.object.zoom = scope.zoom0;

          scope.object.updateProjectionMatrix();
          scope.dispatchEvent( changeEvent );

          scope.update();

          state = STATE.NONE;

        };

        // this method is exposed, but perhaps it would be better if we can make it private...
        this.update = function () {

          var offset = new THREE.Vector3();

          // so camera.up is the orbit axis
          var quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );
          var quatInverse = quat.clone().inverse();

          var lastPosition = new THREE.Vector3();
          var lastQuaternion = new THREE.Quaternion();

          return function update() {

            var position = scope.object.position;

            offset.copy( position ).sub( scope.target );

            // rotate offset to "y-axis-is-up" space
            offset.applyQuaternion( quat );

            // angle from z-axis around y-axis
            spherical.setFromVector3( offset );

            if ( scope.autoRotate && state === STATE.NONE ) {

              rotateLeft( getAutoRotationAngle() );

            }

            spherical.theta += sphericalDelta.theta;
            spherical.phi += sphericalDelta.phi;

            // restrict theta to be between desired limits
            spherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );

            // restrict phi to be between desired limits
            spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );

            spherical.makeSafe();


            spherical.radius *= scale;

            // restrict radius to be between desired limits
            spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );

            // move target to panned location
            scope.target.add( panOffset );

            offset.setFromSpherical( spherical );

            // rotate offset back to "camera-up-vector-is-up" space
            offset.applyQuaternion( quatInverse );

            position.copy( scope.target ).add( offset );

            scope.object.lookAt( scope.target );

            if ( scope.enableDamping === true ) {

              sphericalDelta.theta *= ( 1 - scope.dampingFactor );
              sphericalDelta.phi *= ( 1 - scope.dampingFactor );

              panOffset.multiplyScalar( 1 - scope.dampingFactor );

            } else {

              sphericalDelta.set( 0, 0, 0 );

              panOffset.set( 0, 0, 0 );

            }

            scale = 1;

            // update condition is:
            // min(camera displacement, camera rotation in radians)^2 > EPS
            // using small-angle approximation cos(x/2) = 1 - x^2 / 8

            if ( zoomChanged ||
                    lastPosition.distanceToSquared( scope.object.position ) > EPS ||
                    8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {

              scope.dispatchEvent( changeEvent );

              lastPosition.copy( scope.object.position );
              lastQuaternion.copy( scope.object.quaternion );
              zoomChanged = false;

              return true;

            }

            return false;

          };

        }();

        this.dispose = function () {

          scope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );
          scope.domElement.removeEventListener( 'mousedown', onMouseDown, false );
          scope.domElement.removeEventListener( 'wheel', onMouseWheel, false );

          scope.domElement.removeEventListener( 'touchstart', onTouchStart, false );
          scope.domElement.removeEventListener( 'touchend', onTouchEnd, false );
          scope.domElement.removeEventListener( 'touchmove', onTouchMove, false );

          document.removeEventListener( 'mousemove', onMouseMove, false );
          document.removeEventListener( 'mouseup', onMouseUp, false );

          window.removeEventListener( 'keydown', onKeyDown, false );

          //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

        };

        //
        // internals
        //

        var scope = this;

        var changeEvent = { type: 'change' };
        var startEvent = { type: 'start' };
        var endEvent = { type: 'end' };

        var STATE = { NONE: - 1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY_PAN: 4 };

        var state = STATE.NONE;

        var EPS = 0.000001;

        // current position in spherical coordinates
        var spherical = new THREE.Spherical();
        var sphericalDelta = new THREE.Spherical();

        var scale = 1;
        var panOffset = new THREE.Vector3();
        var zoomChanged = false;

        var rotateStart = new THREE.Vector2();
        var rotateEnd = new THREE.Vector2();
        var rotateDelta = new THREE.Vector2();

        var panStart = new THREE.Vector2();
        var panEnd = new THREE.Vector2();
        var panDelta = new THREE.Vector2();

        var dollyStart = new THREE.Vector2();
        var dollyEnd = new THREE.Vector2();
        var dollyDelta = new THREE.Vector2();

        function getAutoRotationAngle() {

          return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

        }

        function getZoomScale() {

          return Math.pow( 0.95, scope.zoomSpeed );

        }

        function rotateLeft( angle ) {

          sphericalDelta.theta -= angle;

        }

        function rotateUp( angle ) {

          sphericalDelta.phi -= angle;

        }

        var panLeft = function () {

          var v = new THREE.Vector3();

          return function panLeft( distance, objectMatrix ) {

            v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
            v.multiplyScalar( - distance );

            panOffset.add( v );

          };

        }();

        var panUp = function () {

          var v = new THREE.Vector3();

          return function panUp( distance, objectMatrix ) {

            if ( scope.screenSpacePanning === true ) {

              v.setFromMatrixColumn( objectMatrix, 1 );

            } else {

              v.setFromMatrixColumn( objectMatrix, 0 );
              v.crossVectors( scope.object.up, v );

            }

            v.multiplyScalar( distance );

            panOffset.add( v );

          };

        }();

        // deltaX and deltaY are in pixels; right and down are positive
        var pan = function () {

          var offset = new THREE.Vector3();

          return function pan( deltaX, deltaY ) {

            var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

            if ( scope.object.isPerspectiveCamera ) {

              // perspective
              var position = scope.object.position;
              offset.copy( position ).sub( scope.target );
              var targetDistance = offset.length();

              // half of the fov is center to top of screen
              targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

              // we use only clientHeight here so aspect ratio does not distort speed
              panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
              panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );

            } else if ( scope.object.isOrthographicCamera ) {

              // orthographic
              panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
              panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );

            } else {

              // camera neither orthographic nor perspective
              console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
              scope.enablePan = false;

            }

          };

        }();

        function dollyIn( dollyScale ) {

          if ( scope.object.isPerspectiveCamera ) {

            scale /= dollyScale;

          } else if ( scope.object.isOrthographicCamera ) {

            scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );
            scope.object.updateProjectionMatrix();
            zoomChanged = true;

          } else {

            console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
            scope.enableZoom = false;

          }

        }

        function dollyOut( dollyScale ) {

          if ( scope.object.isPerspectiveCamera ) {

            scale *= dollyScale;

          } else if ( scope.object.isOrthographicCamera ) {

            scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );
            scope.object.updateProjectionMatrix();
            zoomChanged = true;

          } else {

            console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
            scope.enableZoom = false;

          }

        }

        //
        // event callbacks - update the object state
        //

        function handleMouseDownRotate( event ) {

          //console.log( 'handleMouseDownRotate' );

          rotateStart.set( event.clientX, event.clientY );

        }

        function handleMouseDownDolly( event ) {

          //console.log( 'handleMouseDownDolly' );

          dollyStart.set( event.clientX, event.clientY );

        }

        function handleMouseDownPan( event ) {

          //console.log( 'handleMouseDownPan' );

          panStart.set( event.clientX, event.clientY );

        }

        function handleMouseMoveRotate( event ) {

          //console.log( 'handleMouseMoveRotate' );

          rotateEnd.set( event.clientX, event.clientY );

          rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

          var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

          // rotating across whole screen goes 360 degrees around
          rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth );

          // rotating up and down along whole screen attempts to go 360, but limited to 180
          rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

          rotateStart.copy( rotateEnd );

          scope.update();

        }

        function handleMouseMoveDolly( event ) {

          //console.log( 'handleMouseMoveDolly' );

          dollyEnd.set( event.clientX, event.clientY );

          dollyDelta.subVectors( dollyEnd, dollyStart );

          if ( dollyDelta.y > 0 ) {

            dollyIn( getZoomScale() );

          } else if ( dollyDelta.y < 0 ) {

            dollyOut( getZoomScale() );

          }

          dollyStart.copy( dollyEnd );

          scope.update();

        }

        function handleMouseMovePan( event ) {

          //console.log( 'handleMouseMovePan' );

          panEnd.set( event.clientX, event.clientY );

          panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

          pan( panDelta.x, panDelta.y );

          panStart.copy( panEnd );

          scope.update();

        }

        function handleMouseUp( event ) {

          // console.log( 'handleMouseUp' );

        }

        function handleMouseWheel( event ) {

          // console.log( 'handleMouseWheel' );

          if ( event.deltaY < 0 ) {

            dollyOut( getZoomScale() );

          } else if ( event.deltaY > 0 ) {

            dollyIn( getZoomScale() );

          }

          scope.update();

        }

        function handleKeyDown( event ) {

          //console.log( 'handleKeyDown' );

          switch ( event.keyCode ) {

            case scope.keys.UP:
              pan( 0, scope.keyPanSpeed );
              scope.update();
              break;

            case scope.keys.BOTTOM:
              pan( 0, - scope.keyPanSpeed );
              scope.update();
              break;

            case scope.keys.LEFT:
              pan( scope.keyPanSpeed, 0 );
              scope.update();
              break;

            case scope.keys.RIGHT:
              pan( - scope.keyPanSpeed, 0 );
              scope.update();
              break;

          }

        }

        function handleTouchStartRotate( event ) {

          //console.log( 'handleTouchStartRotate' );

          rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

        }

        function handleTouchStartDollyPan( event ) {

          //console.log( 'handleTouchStartDollyPan' );

          if ( scope.enableZoom ) {

            var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
            var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

            var distance = Math.sqrt( dx * dx + dy * dy );

            dollyStart.set( 0, distance );

          }

          if ( scope.enablePan ) {

            var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
            var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

            panStart.set( x, y );

          }

        }

        function handleTouchMoveRotate( event ) {

          //console.log( 'handleTouchMoveRotate' );

          rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

          rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

          var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

          // rotating across whole screen goes 360 degrees around
          rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth );

          // rotating up and down along whole screen attempts to go 360, but limited to 180
          rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

          rotateStart.copy( rotateEnd );

          scope.update();

        }

        function handleTouchMoveDollyPan( event ) {

          //console.log( 'handleTouchMoveDollyPan' );

          if ( scope.enableZoom ) {

            var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
            var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

            var distance = Math.sqrt( dx * dx + dy * dy );

            dollyEnd.set( 0, distance );

            dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );

            dollyIn( dollyDelta.y );

            dollyStart.copy( dollyEnd );

          }

          if ( scope.enablePan ) {

            var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
            var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

            panEnd.set( x, y );

            panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

            pan( panDelta.x, panDelta.y );

            panStart.copy( panEnd );

          }

          scope.update();

        }

        function handleTouchEnd( event ) {

          //console.log( 'handleTouchEnd' );

        }

        //
        // event handlers - FSM: listen for events and reset state
        //

        function onMouseDown( event ) {

          if ( scope.enabled === false ) return;

          event.preventDefault();

          switch ( event.button ) {

            case scope.mouseButtons.ORBIT:

              if ( scope.enableRotate === false ) return;

              handleMouseDownRotate( event );

              state = STATE.ROTATE;

              break;

            case scope.mouseButtons.ZOOM:

              if ( scope.enableZoom === false ) return;

              handleMouseDownDolly( event );

              state = STATE.DOLLY;

              break;

            case scope.mouseButtons.PAN:

              if ( scope.enablePan === false ) return;

              handleMouseDownPan( event );

              state = STATE.PAN;

              break;

          }

          if ( state !== STATE.NONE ) {

            document.addEventListener( 'mousemove', onMouseMove, false );
            document.addEventListener( 'mouseup', onMouseUp, false );

            scope.dispatchEvent( startEvent );

          }

        }

        function onMouseMove( event ) {

          if ( scope.enabled === false ) return;

          event.preventDefault();

          switch ( state ) {

            case STATE.ROTATE:

              if ( scope.enableRotate === false ) return;

              handleMouseMoveRotate( event );

              break;

            case STATE.DOLLY:

              if ( scope.enableZoom === false ) return;

              handleMouseMoveDolly( event );

              break;

            case STATE.PAN:

              if ( scope.enablePan === false ) return;

              handleMouseMovePan( event );

              break;

          }

        }

        function onMouseUp( event ) {

          if ( scope.enabled === false ) return;

          handleMouseUp( event );

          document.removeEventListener( 'mousemove', onMouseMove, false );
          document.removeEventListener( 'mouseup', onMouseUp, false );

          scope.dispatchEvent( endEvent );

          state = STATE.NONE;

        }

        function onMouseWheel( event ) {

          if ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;

          event.stopPropagation();

          scope.dispatchEvent( startEvent );

          handleMouseWheel( event );

          scope.dispatchEvent( endEvent );

        }

        function onKeyDown( event ) {

          if ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;

          handleKeyDown( event );

        }

        function onTouchStart( event ) {

          if ( scope.enabled === false ) return;

          event.preventDefault();

          switch ( event.touches.length ) {

            case 1:	// one-fingered touch: rotate

              if ( scope.enableRotate === false ) return;

              handleTouchStartRotate( event );

              state = STATE.TOUCH_ROTATE;

              break;

            case 2:	// two-fingered touch: dolly-pan

              if ( scope.enableZoom === false && scope.enablePan === false ) return;

              handleTouchStartDollyPan( event );

              state = STATE.TOUCH_DOLLY_PAN;

              break;

            default:

              state = STATE.NONE;

          }

          if ( state !== STATE.NONE ) {

            scope.dispatchEvent( startEvent );

          }

        }

        function onTouchMove( event ) {

          if ( scope.enabled === false ) return;

          event.preventDefault();
          event.stopPropagation();

          switch ( event.touches.length ) {

            case 1: // one-fingered touch: rotate

              if ( scope.enableRotate === false ) return;
              if ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?

              handleTouchMoveRotate( event );

              break;

            case 2: // two-fingered touch: dolly-pan

              if ( scope.enableZoom === false && scope.enablePan === false ) return;
              if ( state !== STATE.TOUCH_DOLLY_PAN ) return; // is this needed?

              handleTouchMoveDollyPan( event );

              break;

            default:

              state = STATE.NONE;

          }

        }

        function onTouchEnd( event ) {

          if ( scope.enabled === false ) return;

          handleTouchEnd( event );

          scope.dispatchEvent( endEvent );

          state = STATE.NONE;

        }

        function onContextMenu( event ) {

          if ( scope.enabled === false ) return;

          event.preventDefault();

        }

        //

        scope.domElement.addEventListener( 'contextmenu', onContextMenu, false );

        scope.domElement.addEventListener( 'mousedown', onMouseDown, false );
        scope.domElement.addEventListener( 'wheel', onMouseWheel, false );

        scope.domElement.addEventListener( 'touchstart', onTouchStart, false );
        scope.domElement.addEventListener( 'touchend', onTouchEnd, false );
        scope.domElement.addEventListener( 'touchmove', onTouchMove, false );

        window.addEventListener( 'keydown', onKeyDown, false );

        // force an update at start

        this.update();

      };

      THREE.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );
      THREE.OrbitControls.prototype.constructor = THREE.OrbitControls;

      Object.defineProperties( THREE.OrbitControls.prototype, {

        center: {

          get: function () {

            console.warn( 'THREE.OrbitControls: .center has been renamed to .target' );
            return this.target;

          }

        },

        // backward compatibility

        noZoom: {

          get: function () {

            console.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );
            return ! this.enableZoom;

          },

          set: function ( value ) {

            console.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );
            this.enableZoom = ! value;

          }

        },

        noRotate: {

          get: function () {

            console.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );
            return ! this.enableRotate;

          },

          set: function ( value ) {

            console.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );
            this.enableRotate = ! value;

          }

        },

        noPan: {

          get: function () {

            console.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );
            return ! this.enablePan;

          },

          set: function ( value ) {

            console.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );
            this.enablePan = ! value;

          }

        },

        noKeys: {

          get: function () {

            console.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );
            return ! this.enableKeys;

          },

          set: function ( value ) {

            console.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );
            this.enableKeys = ! value;

          }

        },

        staticMoving: {

          get: function () {

            console.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );
            return ! this.enableDamping;

          },

          set: function ( value ) {

            console.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );
            this.enableDamping = ! value;

          }

        },

        dynamicDampingFactor: {

          get: function () {

            console.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );
            return this.dampingFactor;

          },

          set: function ( value ) {

            console.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );
            this.dampingFactor = value;

          }

        }

      } );

    </script>

    <script>
      // stats.js - http://github.com/mrdoob/stats.js
      var Stats=function(){function h(a){c.appendChild(a.dom);return a}function k(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?"block":"none";l=a}var l=0,c=document.createElement("div");c.style.cssText="position:fixed;top:0;right:0;cursor:pointer;opacity:0.9;z-index:10000";c.addEventListener("click",function(a){a.preventDefault();k(++l%c.children.length)},!1);var g=(performance||Date).now(),e=g,a=0,r=h(new Stats.Panel("FPS","#0ff","#002")),f=h(new Stats.Panel("MS","#0f0","#020"));
        if(self.performance&&self.performance.memory)var t=h(new Stats.Panel("MB","#f08","#201"));k(0);return{REVISION:16,dom:c,addPanel:h,showPanel:k,begin:function(){g=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();f.update(c-g,200);if(c>e+1E3&&(r.update(1E3*a/(c-e),100),e=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){g=this.end()},domElement:c,setMode:k}};
      Stats.Panel=function(h,k,l){var c=Infinity,g=0,e=Math.round,a=e(window.devicePixelRatio||1),r=80*a,f=48*a,t=3*a,u=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement("canvas");q.width=r;q.height=f;q.style.cssText="width:80px;height:48px";var b=q.getContext("2d");b.font="bold "+9*a+"px Helvetica,Arial,sans-serif";b.textBaseline="top";b.fillStyle=l;b.fillRect(0,0,r,f);b.fillStyle=k;b.fillText(h,t,u);b.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(f,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               v){c=Math.min(c,f);g=Math.max(g,f);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=k;b.fillText(e(f)+" "+h+" ("+e(c)+"-"+e(g)+")",t,u);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,e((1-f/v)*p))}}};"object"===typeof module&&(module.exports=Stats);
    </script>

    <script>
        // - Global variables -

        // Heightfield parameters
        var terrainWidthExtents = 100;
        var terrainDepthExtents = 100;
        var terrainWidth = 128;
        var terrainDepth = 128;
        var terrainHalfWidth = terrainWidth / 2;
        var terrainHalfDepth = terrainDepth / 2;
        var terrainMaxHeight = 8;
        var terrainMinHeight = -2;

        // Graphics variables
        var container, stats;
        var camera, controls, scene, renderer;
        var terrainMesh, texture;
        var clock = new THREE.Clock();

        // Physics variables
        var collisionConfiguration;
        var dispatcher;
        var broadphase;
        var solver;
        var physicsWorld;
        var terrainBody;
        var dynamicObjects = [];
        var transformAux1 = new Ammo.btTransform();

        var heightData = null;
        var ammoHeightData = null;

        var time = 0;
        var objectTimePeriod = 3;
        var timeNextSpawn = time + objectTimePeriod;
        var maxNumObjects = 30;

        // - Main code -
        init();
        animate();

        function init() {

          heightData = generateHeight( terrainWidth, terrainDepth, terrainMinHeight, terrainMaxHeight );

          initGraphics();

          initPhysics();

        }

        function initGraphics() {

          container = document.getElementById( 'container' );

          camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.2, 2000 );

          scene = new THREE.Scene();

          camera.position.y = heightData[ terrainHalfWidth + terrainHalfDepth * terrainWidth ] * ( terrainMaxHeight - terrainMinHeight ) + 5;

          camera.position.z =  terrainDepthExtents / 2;
          camera.lookAt( new THREE.Vector3( 0, 0, 0 ) );

          controls = new THREE.OrbitControls( camera );

          var geometry = new THREE.PlaneBufferGeometry( 100, 100, terrainWidth - 1, terrainDepth - 1 );
          geometry.rotateX( - Math.PI / 2 );

          var vertices = geometry.attributes.position.array;

          for ( var i = 0, j = 0, l = vertices.length; i < l; i ++, j += 3 ) {

            // j + 1 because it is the y component that we modify
            vertices[ j + 1 ] = heightData[ i ];

          }

          geometry.computeVertexNormals();

          var groundMaterial = new THREE.MeshPhongMaterial( { color: 0xC7C7C7 } );
          terrainMesh = new THREE.Mesh( geometry, groundMaterial );
          scene.add( terrainMesh );

          var textureLoader = new THREE.TextureLoader();
          textureLoader.load( "/artificial/reality/ammo/textures/grid.png", function( texture ) {
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set( terrainWidth - 1, terrainDepth - 1 );
            groundMaterial.map = texture;
            groundMaterial.needsUpdate = true;

          } );

          var dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
          dirLight.position.set( 10, 10, 5 );
          scene.add( dirLight );


          renderer = new THREE.WebGLRenderer();
          renderer.setClearColor( 0xbfd1e5 );
          renderer.setPixelRatio( window.devicePixelRatio );
          renderer.setSize( window.innerWidth, window.innerHeight );

          container.innerHTML = "";

          container.appendChild( renderer.domElement );

          stats = new Stats();
          stats.domElement.style.position = 'absolute';
          stats.domElement.style.top = '0px';
          container.appendChild( stats.domElement );

          //

          window.addEventListener( 'resize', onWindowResize, false );

        }

        function onWindowResize() {

          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();

          renderer.setSize( window.innerWidth, window.innerHeight );

        }

        function initPhysics() {

          // Physics configuration

          collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
          dispatcher = new Ammo.btCollisionDispatcher( collisionConfiguration );
          broadphase = new Ammo.btDbvtBroadphase();
          solver = new Ammo.btSequentialImpulseConstraintSolver();
          physicsWorld = new Ammo.btDiscreteDynamicsWorld( dispatcher, broadphase, solver, collisionConfiguration );
          physicsWorld.setGravity( new Ammo.btVector3( 0, - 6, 0 ) );

          // Create the terrain body

          groundShape = createTerrainShape( heightData );
          var groundTransform = new Ammo.btTransform();
          groundTransform.setIdentity();
          // Shifts the terrain, since bullet re-centers it on its bounding box.
          groundTransform.setOrigin( new Ammo.btVector3( 0, ( terrainMaxHeight + terrainMinHeight ) / 2, 0 ) );
          var groundMass = 0;
          var groundLocalInertia = new Ammo.btVector3( 0, 0, 0 );
          var groundMotionState = new Ammo.btDefaultMotionState( groundTransform );
          var groundBody = new Ammo.btRigidBody( new Ammo.btRigidBodyConstructionInfo( groundMass, groundMotionState, groundShape, groundLocalInertia ) );
          physicsWorld.addRigidBody( groundBody );

        }

        function generateHeight( width, depth, minHeight, maxHeight ) {

          // Generates the height data (a sinus wave)

          var size = width * depth;
          var data = new Float32Array( size );

          var hRange = maxHeight - minHeight;
          var w2 = width / 2;
          var d2 = depth / 2;
          var phaseMult = 12;

          var p = 0;
          for ( var j = 0; j < depth; j ++ ) {
            for ( var i = 0; i < width; i ++ ) {

              var radius = Math.sqrt(
                      Math.pow( ( i - w2 ) / w2, 2.0 ) +
                      Math.pow( ( j - d2 ) / d2, 2.0 ) );

              var height = ( Math.sin( radius * phaseMult ) + 1 ) * 0.5  * hRange + minHeight;

              data[ p ] = height;

              p++;
            }
          }

          return data;

        }

        function createTerrainShape() {

          // This parameter is not really used, since we are using PHY_FLOAT height data type and hence it is ignored
          var heightScale = 1;

          // Up axis = 0 for X, 1 for Y, 2 for Z. Normally 1 = Y is used.
          var upAxis = 1;

          // hdt, height data type. "PHY_FLOAT" is used. Possible values are "PHY_FLOAT", "PHY_UCHAR", "PHY_SHORT"
          var hdt = "PHY_FLOAT";

          // Set this to your needs (inverts the triangles)
          var flipQuadEdges = false;

          // Creates height data buffer in Ammo heap
          ammoHeightData = Ammo._malloc( 4 * terrainWidth * terrainDepth );

          // Copy the javascript height data array to the Ammo one.
          var p = 0;
          var p2 = 0;
          for ( var j = 0; j < terrainDepth; j ++ ) {
            for ( var i = 0; i < terrainWidth; i ++ ) {

              // write 32-bit float data to memory
              Ammo.HEAPF32[ammoHeightData + p2 >> 2] = heightData[ p ];

              p ++;

              // 4 bytes/float
              p2 += 4;
            }
          }

          // Creates the heightfield physics shape
          var heightFieldShape = new Ammo.btHeightfieldTerrainShape(

                  terrainWidth,
                  terrainDepth,

                  ammoHeightData,

                  heightScale,
                  terrainMinHeight,
                  terrainMaxHeight,

                  upAxis,
                  hdt,
                  flipQuadEdges
          );

          // Set horizontal scale
          var scaleX = terrainWidthExtents / ( terrainWidth - 1 );
          var scaleZ = terrainDepthExtents / ( terrainDepth - 1 );
          heightFieldShape.setLocalScaling( new Ammo.btVector3( scaleX, 1, scaleZ ) );

          heightFieldShape.setMargin( 0.05 );

          return heightFieldShape;

        }

        function generateObject() {

          var numTypes = 4;
          var objectType = Math.ceil( Math.random() * numTypes );

          var threeObject = null;
          var shape = null;

          var objectSize = 3;
          var margin = 0.05;

          switch ( objectType ) {
            case 1:
              // Sphere
              var radius = 1 + Math.random() * objectSize;
              threeObject = new THREE.Mesh( new THREE.SphereGeometry( radius, 20, 20 ), createObjectMaterial() );
              shape = new Ammo.btSphereShape( radius );
              shape.setMargin( margin );
              break;
            case 2:
              // Box
              var sx = 1 + Math.random() * objectSize;
              var sy = 1 + Math.random() * objectSize;
              var sz = 1 + Math.random() * objectSize;
              threeObject = new THREE.Mesh( new THREE.BoxGeometry( sx, sy, sz, 1, 1, 1 ), createObjectMaterial() );
              shape = new Ammo.btBoxShape( new Ammo.btVector3( sx * 0.5, sy * 0.5, sz * 0.5 ) );
              shape.setMargin( margin );
              break;
            case 3:
              // Cylinder
              var radius = 1 + Math.random() * objectSize;
              var height = 1 + Math.random() * objectSize;
              threeObject = new THREE.Mesh( new THREE.CylinderGeometry( radius, radius, height, 20, 1 ), createObjectMaterial() );
              shape = new Ammo.btCylinderShape( new Ammo.btVector3( radius, height * 0.5, radius ) );
              shape.setMargin( margin );
              break;
            default:
              // Cone
              var radius = 1 + Math.random() * objectSize;
              var height = 2 + Math.random() * objectSize;
              threeObject = new THREE.Mesh( new THREE.CylinderGeometry( 0, radius, height, 20, 2 ), createObjectMaterial() );
              shape = new Ammo.btConeShape( radius, height );
              break;
          }

          threeObject.position.set( ( Math.random() - 0.5 ) * terrainWidth * 0.6, terrainMaxHeight + objectSize + 2, ( Math.random() - 0.5 ) * terrainDepth * 0.6 );

          var mass = objectSize * 5;
          var localInertia = new Ammo.btVector3( 0, 0, 0 );
          shape.calculateLocalInertia( mass, localInertia );
          var transform = new Ammo.btTransform();
          transform.setIdentity();
          var pos = threeObject.position;
          transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
          var motionState = new Ammo.btDefaultMotionState( transform );
          var rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, shape, localInertia );
          var body = new Ammo.btRigidBody( rbInfo );

          threeObject.userData.physicsBody = body;

          scene.add( threeObject );
          dynamicObjects.push( threeObject );

          physicsWorld.addRigidBody( body );



        }

        function createObjectMaterial() {
          var c = Math.floor( Math.random() * ( 1 << 24 ) );
          return new THREE.MeshPhongMaterial( { color: c } );
        }

        function animate() {

          requestAnimationFrame( animate );

          render();
          stats.update();

        }

        function render() {

          var deltaTime = clock.getDelta();

          if ( dynamicObjects.length < maxNumObjects && time > timeNextSpawn ) {
            generateObject();
            timeNextSpawn = time + objectTimePeriod;
          }

          updatePhysics( deltaTime );

          controls.update( deltaTime );

          renderer.render( scene, camera );

          time += deltaTime;

        }

        function updatePhysics( deltaTime ) {

          physicsWorld.stepSimulation( deltaTime, 10 );

          // Update objects
          for ( var i = 0, il = dynamicObjects.length; i < il; i++ ) {
            var objThree = dynamicObjects[ i ];
            var objPhys = objThree.userData.physicsBody;
            var ms = objPhys.getMotionState();
            if ( ms ) {

              ms.getWorldTransform( transformAux1 );
              var p = transformAux1.getOrigin();
              var q = transformAux1.getRotation();
              objThree.position.set( p.x(), p.y(), p.z() );
              objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );

            }
          }
        }

    </script>
  </div>
</template>
